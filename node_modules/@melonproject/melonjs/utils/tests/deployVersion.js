"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const AccountingFactory_1 = require("../../contracts/fund/accounting/AccountingFactory");
const AccountingFactory_bin_1 = require("../../abis/AccountingFactory.bin");
const Version_1 = require("../../contracts/version/Version");
const Version_bin_1 = require("../../abis/Version.bin");
const randomAddress_1 = require("./randomAddress");
const bignumber_js_1 = require("bignumber.js");
const FeeManagerFactory_1 = require("../../contracts/fund/fees/FeeManagerFactory");
function deployVersion(environment, creator, registry, weth) {
    return __awaiter(this, void 0, void 0, function* () {
        const deployAccountingFactory = AccountingFactory_1.AccountingFactory.deploy(environment, AccountingFactory_bin_1.AccountingFactoryBytecode, environment.accounts[0]);
        const accountingFactory = yield deployAccountingFactory.send(yield deployAccountingFactory.prepare());
        const deployFeeManagerFactory = FeeManagerFactory_1.FeeManagerFactory.deploy(environment, AccountingFactory_bin_1.AccountingFactoryBytecode, environment.accounts[0]);
        const feeManagerFactory = yield deployFeeManagerFactory.send(yield deployAccountingFactory.prepare());
        const deploy = Version_1.Version.deploy(environment, Version_bin_1.VersionBytecode, creator, {
            accountingFactory: accountingFactory.contract.address,
            feeManagerFactory: feeManagerFactory.contract.address,
            participationFactory: randomAddress_1.randomAddress(),
            policyManagerFactory: randomAddress_1.randomAddress(),
            sharesFactory: randomAddress_1.randomAddress(),
            tradingFactory: randomAddress_1.randomAddress(),
            vaultFactory: randomAddress_1.randomAddress(),
            registry: registry.contract.address,
            postDeployOwner: creator,
        });
        const version = yield deploy.send(yield deploy.prepare());
        {
            const tx = registry.registerAsset(creator, {
                address: weth.contract.address,
                name: 'Test Asset',
                symbol: 'TAT',
                url: 'https://tat.tat/',
                reserveMin: new bignumber_js_1.BigNumber(100000),
                standards: [1, 2, 3],
                sigs: ['0x30303030'],
            });
            yield tx.send(yield tx.prepare());
        }
        {
            const tx = registry.setNativeAsset(creator, weth.contract.address);
            yield tx.send(yield tx.prepare());
        }
        {
            const tx = registry.registerVersion(creator, version.contract.address, 'test-version');
            yield tx.send(yield tx.prepare());
        }
        {
            const tx = registry.setMlnToken(creator, randomAddress_1.randomAddress());
            yield tx.send(yield tx.prepare());
        }
        return version;
    });
}
exports.deployVersion = deployVersion;
