"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bignumber_js_1 = __importDefault(require("bignumber.js"));
class Transaction {
    constructor(transaction, environment, from, contract, method, args, value, validate = () => Promise.resolve(), amguFn, incentiveFn) {
        this.transaction = transaction;
        this.environment = environment;
        this.from = from;
        this.contract = contract;
        this.method = method;
        this.args = args;
        this.value = value;
        this.validate = validate;
        this.amguFn = amguFn;
        this.incentiveFn = incentiveFn;
        this.amguPayable = false;
        this.incentivePayable = false;
        this.amguPayable = !!amguFn;
        this.incentivePayable = !!incentiveFn;
    }
    send(options) {
        const opts = this.checkSendOptions(options);
        return this.transaction.send(opts);
    }
    prepare(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const gas = (options === null || options === void 0 ? void 0 : options.gas) || (yield this.estimate(options));
            const [amgu, incentive] = yield Promise.all([
                this.amguPayable && this.amguFn && this.amguFn(gas),
                this.incentivePayable && this.incentiveFn && this.incentiveFn(gas),
            ]);
            const opts = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ gas }, (amgu && { amgu })), (incentive && { incentive })), ((options === null || options === void 0 ? void 0 : options.value) && { value: options.value })), ((options === null || options === void 0 ? void 0 : options.from) && { from: options.from })), ((options === null || options === void 0 ? void 0 : options.gasPrice) && { gasPrice: options.gasPrice }));
            return opts;
        });
    }
    estimate(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const from = (options === null || options === void 0 ? void 0 : options.from) || this.from;
            const gas = options === null || options === void 0 ? void 0 : options.gas;
            let value = (options === null || options === void 0 ? void 0 : options.value) || this.value;
            if (this.amguFn) {
                // We don't know the amgu price at this stage yet, so we just send all
                // available ETH for the gasEstimation. This should throw if amgu price
                // in ETH is bigger than the available balance.
                value = new bignumber_js_1.default(yield this.environment.client.getBalance(from));
            }
            const opts = Object.assign(Object.assign(Object.assign({}, (value && { value: value.toFixed() })), (from && { from })), (gas && { gas }));
            const [estimation, block] = yield Promise.all([
                this.transaction.estimateGas(opts),
                this.environment.client.getBlock('latest'),
            ]);
            return Math.ceil(Math.min(estimation * 1.1, block.gasLimit));
        });
    }
    checkEthBalance(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const opts = this.checkSendOptions(options);
            const gasValue = new bignumber_js_1.default(options.gas).multipliedBy(new bignumber_js_1.default(options.gasPrice));
            const totalValue = new bignumber_js_1.default(opts.value).plus(gasValue);
            const balance = new bignumber_js_1.default(yield this.environment.client.getBalance(options.from));
            if (balance.isLessThan(totalValue)) {
                throw new Error('Insufficient ETH to pay for this transaction.');
            }
        });
    }
    checkSendOptions(options) {
        const from = (options && options.from) || this.from;
        let value = (options && options.value) || this.value;
        if (this.amguPayable && !options.amgu) {
            throw new Error('Missing amgu for transaction.');
        }
        if (this.incentivePayable && !options.incentive) {
            throw new Error('Missing incentive for transaction.');
        }
        if (options.amgu) {
            value = (value || new bignumber_js_1.default(0)).plus(options.amgu);
        }
        if (options.incentive) {
            value = (value || new bignumber_js_1.default(0)).plus(options.incentive);
        }
        return Object.assign(Object.assign(Object.assign(Object.assign({}, (value && { value: value.toFixed() })), (from && { from })), ((options === null || options === void 0 ? void 0 : options.gas) && { gas: options.gas })), ((options === null || options === void 0 ? void 0 : options.gasPrice) && { gasPrice: options.gasPrice }));
    }
}
exports.Transaction = Transaction;
class Deployment extends Transaction {
    constructor(clazz, environment, transaction, from, args) {
        super(environment, transaction, from, undefined, 'deploy', args);
        this.clazz = clazz;
        this.environment = environment;
        this.transaction = transaction;
        this.from = from;
        this.args = args;
    }
    send(options) {
        const result = super.send(options);
        const promise = new Promise((resolve, reject) => {
            result.catch(reject);
            result.then((receipt) => {
                try {
                    resolve(new this.clazz(this.environment, receipt));
                }
                catch (e) {
                    reject(e);
                }
            });
        });
        return new Proxy(result, {
            get: (target, name) => {
                if (name === 'resolve' || name === 'reject') {
                    return target[name];
                }
                if (name === 'then') {
                    return promise.then.bind(promise);
                }
                if (name === 'catch') {
                    return promise.catch.bind(promise);
                }
                if (target[name]) {
                    return target[name];
                }
            },
        });
    }
}
exports.Deployment = Deployment;
