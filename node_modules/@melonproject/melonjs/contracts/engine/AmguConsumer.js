"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Contract_1 = require("../../Contract");
const AmguConsumer_abi_1 = require("../../abis/AmguConsumer.abi");
const Engine_1 = require("./Engine");
const IPriceSource_1 = require("../prices/IPriceSource");
const ERC20WithFields_1 = require("../dependencies/token/ERC20WithFields");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
class AmguConsumer extends Contract_1.Contract {
    /**
     * Gets the amgu token.
     *
     * @param block The block number to execute the call on.
     */
    getAmguToken(block) {
        return this.makeCall('mlnToken', undefined, block);
    }
    /**
     * Gets the engine address.
     *
     * @param block The block number to execute the call on.
     */
    getEngine(block) {
        return this.makeCall('engine', undefined, block);
    }
    /**
     * Gets the price source address.
     *
     * @param block The block number to execute the call on.
     */
    getPriceSource(block) {
        return this.makeCall('priceSource', undefined, block);
    }
    /**
     * Gets the version address.
     *
     * @param block The block number to execute the call on.
     */
    getVersion(block) {
        return this.makeCall('version', undefined, block);
    }
    /**
     * Calculates the required AMGU value for a transaction.
     *
     * @param gasEstimation The gas estimation value.
     * @param block The block number to execute the call on.
     */
    calculateAmgu(gasEstimation, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const [amguTokenAddress, engineAddress, priceSourceAddress] = yield Promise.all([
                this.getAmguToken(block),
                this.getEngine(block),
                this.getPriceSource(block),
            ]);
            // TODO: Can we derive the price feed type somehow or create a lightweight, common denominator just based
            // on the interface for cases like this?
            const prices = new IPriceSource_1.IPriceSource(this.environment, priceSourceAddress);
            const engine = new Engine_1.Engine(this.environment, engineAddress);
            const amgu = new ERC20WithFields_1.ERC20WithFields(this.environment, amguTokenAddress);
            const [amguDecimals, mlnPerAmgu, ethPerMln] = yield Promise.all([
                amgu.getDecimals(block),
                engine.getAmguPrice(block),
                prices.getPrice(amguTokenAddress, block),
            ]);
            const result = new bignumber_js_1.default(1)
                .multipliedBy(mlnPerAmgu)
                .multipliedBy(ethPerMln.price)
                .multipliedBy(gasEstimation)
                .dividedBy(new bignumber_js_1.default(10).exponentiatedBy(amguDecimals))
                .decimalPlaces(0, bignumber_js_1.default.ROUND_CEIL);
            return result;
        });
    }
}
exports.AmguConsumer = AmguConsumer;
AmguConsumer.abi = AmguConsumer_abi_1.AmguConsumerAbi;
