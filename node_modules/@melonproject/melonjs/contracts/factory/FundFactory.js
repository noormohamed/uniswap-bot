"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Contract_1 = require("../../Contract");
const FundFactory_abi_1 = require("../../abis/FundFactory.abi");
const Factory_1 = require("./Factory");
const applyMixins_1 = require("../../utils/applyMixins");
const Registry_1 = require("../version/Registry");
const isZeroAddress_1 = require("../../utils/isZeroAddress");
const stringToBytes_1 = require("../../utils/stringToBytes");
const AmguConsumer_1 = require("../engine/AmguConsumer");
const FundFactory_error_1 = require("./FundFactory.error");
const Registry_error_1 = require("../version/Registry.error");
const FeeManager_1 = require("../fund/fees/FeeManager");
const IFee_1 = require("../fund/fees/IFee");
const sameAddress_1 = require("../../utils/sameAddress");
class FundFactory extends Contract_1.Contract {
    static deploy(environment, bytecode, from, args) {
        return super.createDeployment(environment, bytecode, from, [
            args.accountingFactory,
            args.feeManagerFactory,
            args.participationFactory,
            args.sharesFactory,
            args.tradingFactory,
            args.vaultFactory,
            args.policyManagerFactory,
            args.version,
        ]);
    }
    validateComponentSet(address) {
        if (isZeroAddress_1.isZeroAddress(address)) {
            throw new FundFactory_error_1.ComponentNotSetError();
        }
    }
    validateHubNotSet(manager) {
        return __awaiter(this, void 0, void 0, function* () {
            const hub = yield this.getManagersToHubs(manager);
            if (!isZeroAddress_1.isZeroAddress(hub)) {
                throw new FundFactory_error_1.ComponentAlreadySetError(hub);
            }
        });
    }
    validateComponentNotSet(manager, component) {
        return __awaiter(this, void 0, void 0, function* () {
            const routes = yield this.getManagersToRoutes(manager);
            if (routes[component] && !isZeroAddress_1.isZeroAddress(routes[component])) {
                throw new FundFactory_error_1.ComponentAlreadySetError(routes[component]);
            }
        });
    }
    /**
     * Get the hub address for manager
     *
     * @param manager The address of the manager
     * @param block The block number to execute the call on.
     */
    getManagersToHubs(manager, block) {
        return this.makeCall('managersToHubs', [manager], block);
    }
    /**
     * Gets the routes for a manager
     *
     * @param manager The address of the manager
     * @param block The block number to execute the call on.
     */
    getManagersToRoutes(manager, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const routes = yield this.makeCall('managersToRoutes', [manager], block);
            const output = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (routes.accounting && !isZeroAddress_1.isZeroAddress(routes.accounting) && { accounting: routes.accounting })), (routes.participation && !isZeroAddress_1.isZeroAddress(routes.participation) && { participation: routes.participation })), (routes.shares && !isZeroAddress_1.isZeroAddress(routes.shares) && { shares: routes.shares })), (routes.trading && !isZeroAddress_1.isZeroAddress(routes.trading) && { trading: routes.trading })), (routes.vault && !isZeroAddress_1.isZeroAddress(routes.vault) && { vault: routes.vault })), (routes.feeManager && !isZeroAddress_1.isZeroAddress(routes.feeManager) && { feeManager: routes.feeManager })), (routes.policyManager && !isZeroAddress_1.isZeroAddress(routes.policyManager) && { policyManager: routes.policyManager }));
            return output;
        });
    }
    /**
     * Begin fund setup transaction
     *
     * @param from The address of the sender
     * @param settings The fund settings
     */
    beginSetup(from, settings) {
        const method = 'beginSetup';
        const args = [
            stringToBytes_1.stringToBytes(settings.name, 32),
            settings.fees,
            settings.feeRates.map((rate) => rate.toFixed(0)),
            settings.feePeriods.map((period) => period.toFixed(0)),
            settings.exchanges,
            settings.adapters,
            settings.denominationAsset,
            settings.defaultAssets,
        ];
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            yield this.validateHubNotSet(from);
            const registry = new Registry_1.Registry(this.environment, yield this.getRegistry());
            // validation for beginSetup
            const [isValidFundName, canUseFundName, denominationAssetRegistered] = yield Promise.all([
                registry.isValidFundName(settings.name),
                registry.canUseFundName(from, settings.name),
                registry.isAssetRegistered(settings.denominationAsset),
            ]);
            if (!isValidFundName) {
                throw new Registry_error_1.InvalidFundNameError(settings.name);
            }
            if (!canUseFundName) {
                throw new Registry_error_1.CannotUseFundNameError(settings.name);
            }
            if (!denominationAssetRegistered) {
                throw new FundFactory_error_1.DenominationAssetNotRegisteredError();
            }
            // validation for createFeeManager
            settings.fees.map((fee) => __awaiter(this, void 0, void 0, function* () {
                if (!(yield registry.isFeeRegistered(fee))) {
                    throw new Registry_error_1.FeeNotRegisteredError(fee);
                }
            }));
            if (settings.fees.length > 0) {
                const fee = new IFee_1.IFee(this.environment, settings.fees[0]);
                if ((yield fee.identifier()) !== 0) {
                    throw new FeeManager_1.ManagementFeeMustBeAtIndexZeroError(settings.fees[0]);
                }
            }
            if (settings.fees.length > 0) {
                const fee = new IFee_1.IFee(this.environment, settings.fees[1]);
                if ((yield fee.identifier()) !== 1) {
                    throw new FeeManager_1.PerformanceFeeMustBeAtIndexOneError(settings.fees[1]);
                }
            }
            // validation for createParticipation
            yield Promise.all(settings.defaultAssets.map((asset) => __awaiter(this, void 0, void 0, function* () {
                if (!(yield registry.isAssetRegistered(asset))) {
                    throw new Registry_error_1.AssetNotRegisteredError(asset);
                }
            })));
            // validation for createTrading
            if (settings.exchanges.length !== settings.adapters.length) {
                throw new FundFactory_error_1.DifferentNumberOfExchangesAndAdaptersError();
            }
            yield Promise.all(settings.adapters.map((adapter, index) => __awaiter(this, void 0, void 0, function* () {
                if (!(yield registry.isExchangeAdapterRegistered(adapter))) {
                    throw new Registry_error_1.ExchangeAdapterNotRegisteredError(adapter);
                }
                const exchangeInformation = yield registry.getExchangeInformation(adapter);
                if (!sameAddress_1.sameAddress(exchangeInformation.exchangeAddress, settings.exchanges[index])) {
                    throw new Registry_error_1.ExchangeAndAdapterDoNotMatchError(settings.exchanges[index], adapter);
                }
            })));
        });
        return this.createTransaction({ from, method, args, validate });
    }
    /**
     * Create the Accounting contract for someone else
     *
     * @param from The address of the sender
     * @param manager The address of the manager
     */
    createAccountingFor(from, manager) {
        const amgu = this.calculateAmgu.bind(this);
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            this.validateComponentSet(yield this.getManagersToHubs(manager));
            this.validateComponentNotSet(manager, 'accounting');
        });
        return this.createTransaction({ from, args: [manager], method: 'createAccountingFor', validate, amgu });
    }
    /**
     * Create the Accounting contract
     *
     * @param from The address of the sender
     */
    createAccounting(from) {
        return this.createAccountingFor(from, from);
    }
    /**
     * Create the FeeManager contract for someone else
     *
     * @param from The address of the sender
     * @param manager The address of the manager
     */
    createFeeManagerFor(from, manager) {
        const amgu = this.calculateAmgu.bind(this);
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            this.validateComponentSet(yield this.getManagersToHubs(manager));
            this.validateComponentNotSet(manager, 'feeManager');
        });
        return this.createTransaction({ from, args: [manager], method: 'createFeeManagerFor', validate, amgu });
    }
    /**
     * Create the FeeManager contract
     *
     * @param from The address of the sender
     */
    createFeeManager(from) {
        return this.createFeeManagerFor(from, from);
    }
    /**
     * Create the Participation contract for someone else
     *
     * @param from The address of the sender
     * @param manager The address of the manager
     */
    createParticipationFor(from, manager) {
        const amgu = this.calculateAmgu.bind(this);
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            this.validateComponentSet(yield this.getManagersToHubs(manager));
            this.validateComponentNotSet(manager, 'participation');
        });
        return this.createTransaction({ from, args: [manager], method: 'createParticipationFor', validate, amgu });
    }
    /**
     * Create the Participation contract
     *
     * @param from The address of the sender
     */
    createParticipation(from) {
        return this.createParticipationFor(from, from);
    }
    /**
     * Create the PolicyManager contract for someone else
     *
     * @param from The address of the sender
     * @param manager The address of the manager
     */
    createPolicyManagerFor(from, manager) {
        const amgu = this.calculateAmgu.bind(this);
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            this.validateComponentSet(yield this.getManagersToHubs(manager));
            this.validateComponentNotSet(manager, 'policyManager');
        });
        return this.createTransaction({ from, args: [manager], method: 'createPolicyManagerFor', validate, amgu });
    }
    /**
     * Create the PolicyManager contract
     *
     * @param from The address of the sender
     */
    createPolicyManager(from) {
        return this.createPolicyManagerFor(from, from);
    }
    /**
     * Create the Shares contract for someone else
     *
     * @param from The address of the sender
     * @param manager The address of the manager
     */
    createSharesFor(from, manager) {
        const amgu = this.calculateAmgu.bind(this);
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            this.validateComponentSet(yield this.getManagersToHubs(manager));
            this.validateComponentNotSet(manager, 'shares');
        });
        return this.createTransaction({ from, args: [manager], method: 'createSharesFor', validate, amgu });
    }
    /**
     * Create the Shares contract
     *
     * @param from The address of the sender
     */
    createShares(from) {
        return this.createSharesFor(from, from);
    }
    /**
     * Create the Trading contract for someone else
     *
     * @param from The address of the sender
     * @param manager The address of the manager
     */
    createTradingFor(from, manager) {
        const amgu = this.calculateAmgu.bind(this);
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            this.validateComponentSet(yield this.getManagersToHubs(manager));
            this.validateComponentNotSet(manager, 'trading');
        });
        return this.createTransaction({ from, args: [manager], method: 'createTradingFor', validate, amgu });
    }
    /**
     * Create the Trading contract
     *
     * @param from The address of the sender
     */
    createTrading(from) {
        return this.createTradingFor(from, from);
    }
    /**
     * Create the Vault contract for someone else
     *
     * @param from The address of the sender
     * @param manager The address of the manager
     */
    createVaultFor(from, manager) {
        const amgu = this.calculateAmgu.bind(this);
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            this.validateComponentSet(yield this.getManagersToHubs(manager));
            this.validateComponentNotSet(manager, 'vault');
        });
        return this.createTransaction({ from, args: [manager], method: 'createVaultFor', validate, amgu });
    }
    /**
     * Create the Vault contract
     *
     * @param from The address of the sender
     */
    createVault(from) {
        return this.createVaultFor(from, from);
    }
    /**
     * Complete the fund setup for someone else
     *
     * @param from The address of the sender
     * @param manager The address of the manager
     */
    completeSetupFor(from, manager) {
        const amgu = this.calculateAmgu.bind(this);
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            const hub = yield this.getManagersToHubs(manager);
            if (yield this.isInstance(hub)) {
                throw new FundFactory_error_1.FundSetupAlreadyCompleteError();
            }
            this.validateComponentSet(yield this.getManagersToHubs(manager));
            const routes = yield this.getManagersToRoutes(manager);
            Object.keys(routes).forEach((route) => {
                this.validateComponentSet(routes[route]);
            });
        });
        return this.createTransaction({ from, args: [manager], method: 'completeSetupFor', validate, amgu });
    }
    /**
     * Complete the fund setup
     *
     * @param from The address of the sender
     */
    completeSetup(from) {
        return this.completeSetupFor(from, from);
    }
    /**
     * Gets the funds address based on the fund id (position in funds array)
     *
     * @param id The id of the fund
     * @param block The block number to execute the call on.
     */
    getFundById(id, block) {
        return this.makeCall('getFundById', [id], block);
    }
    /**
     * Gets the last fund id
     *
     * @param block The block number to execute the call on.
     */
    getLastFundId(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('getLastFundId', undefined, block);
            return parseInt(result, 10);
        });
    }
    /**
     * Gets the address of the MLN token
     *
     * @param block The block number to execute the call on.
     */
    getMlnToken(block) {
        return this.makeCall('mlnToken', undefined, block);
    }
    /**
     * Gets the address of the engine
     *
     * @param block The block number to execute the call on.
     */
    getEngine(block) {
        return this.makeCall('engine', undefined, block);
    }
    /**
     * Gets the address of the price source contract
     *
     * @param block The block number to execute the call on.
     */
    getPriceSource(block) {
        return this.makeCall('priceSource', undefined, block);
    }
    /**
     * Gets the address of the version contract
     *
     * @param block The block number to execute the call on.
     */
    getVersion(block) {
        return this.makeCall('version', undefined, block);
    }
    /**
     * Gets the address of the registry contract
     *
     * @param block The block number to execute the call on.
     */
    getRegistry(block) {
        return this.makeCall('registry', undefined, block);
    }
}
exports.FundFactory = FundFactory;
FundFactory.abi = FundFactory_abi_1.FundFactoryAbi;
applyMixins_1.applyMixins(FundFactory, [Factory_1.Factory, AmguConsumer_1.AmguConsumer]);
