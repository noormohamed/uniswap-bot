"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const Accounting_abi_1 = require("../../../abis/Accounting.abi");
const Contract_1 = require("../../../Contract");
const Spoke_1 = require("../hub/Spoke");
const applyMixins_1 = require("../../../utils/applyMixins");
const toBigNumber_1 = require("../../../utils/toBigNumber");
const AmguConsumer_1 = require("../../engine/AmguConsumer");
const range_1 = require("../../../utils/range");
const FeeManager_1 = require("../fees/FeeManager");
const PerformanceFee_1 = require("../fees/PerformanceFee");
const ValidationError_1 = require("../../../errors/ValidationError");
const Shares_1 = require("../shares/Shares");
const IPriceSource_1 = require("../../prices/IPriceSource");
const sameAddress_1 = require("../../../utils/sameAddress");
const Registry_1 = require("../../version/Registry");
class PerformanceFeeCannotBePaidError extends ValidationError_1.ValidationError {
    constructor(message = 'Performance fee cannot be paid out.') {
        super(message);
        this.name = 'PerformanceFeeCannotBePaidError';
    }
}
exports.PerformanceFeeCannotBePaidError = PerformanceFeeCannotBePaidError;
class Accounting extends Contract_1.Contract {
    static deploy(environment, bytecode, from, args) {
        return super.createDeployment(environment, bytecode, from, [
            args.hub,
            args.denominationAsset,
            args.nativeAsset,
        ]);
    }
    /**
     * Gets the max number of owned assets.
     *
     * @param block The block number to execute the call on.
     */
    getMaxOwnedAssets(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('MAX_OWNED_ASSETS', undefined, block);
            return parseInt(result, 10);
        });
    }
    /**
     * Gets the length of the owned assets array.
     *
     * @param block The block number to execute the call on.
     */
    getOwnedAssetsLength(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('getOwnedAssetsLength', undefined, block);
            return parseInt(result, 10);
        });
    }
    /**
     * Gets the address of an owned asset by its index.
     *
     * @param index The index in the ownedAssets array.
     * @param block The block number to execute the call on.
     */
    getOwnedAsset(index, block) {
        return this.makeCall('ownedAssets', [index], block);
    }
    /**
     * Gets a list of all owned assets.
     *
     * @param block The block number to execute the call on.
     */
    getOwnedAssets(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const length = yield this.getOwnedAssetsLength(block);
            return Promise.all(range_1.range(length).map((_, index) => this.getOwnedAsset(index, block)));
        });
    }
    /**
     * Gets the holding of a specific asset.
     *
     * @param asset The address of the asset.
     * @param block The block number to execute the call on.
     */
    getAssetHolding(asset, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('assetHoldings', [asset], block);
            return toBigNumber_1.toBigNumber(result);
        });
    }
    /**
     * Gets the holdings of all owned assets.
     *
     * @param block The block number to execute the call on.
     */
    getFundHoldings(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const { '0': quantities, '1': assets } = yield this.makeCall('getFundHoldings', undefined, block);
            const output = assets.reduce((carry, key, index) => {
                const amount = toBigNumber_1.toBigNumber(quantities[index]);
                return [...carry, { address: key, amount }];
            }, []);
            return output;
        });
    }
    /**
     * Gets the default share price.
     *
     * @param block The block number to execute the call on.
     */
    getDefaultSharePrice(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('DEFAULT_SHARE_PRICE', undefined, block);
            return toBigNumber_1.toBigNumber(result);
        });
    }
    /**
     * Gets the address of the denomination asset.
     *
     * @param block The block number to execute the call on.
     */
    getDenominationAsset(block) {
        return this.makeCall('DENOMINATION_ASSET', undefined, block);
    }
    /**
     * Gets the address of the native asset (address only).
     *
     * @param block The block number to execute the call on.
     */
    getNativeAsset(block) {
        return this.makeCall('NATIVE_ASSET', undefined, block);
    }
    /**
     * Gets the GAV.
     *
     * @param block The block number to execute the call on.
     */
    getGAV(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('calcGav', undefined, block);
            return toBigNumber_1.toBigNumber(result);
        });
    }
    /**
     * Performs accounting calculations (GAV, NAV, share price, etc).
     *
     * @param block The block number to execute the call on.
     */
    getCalculationResults(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('performCalculations', undefined, block);
            return {
                sharePrice: toBigNumber_1.toBigNumber(result.sharePrice),
                gav: toBigNumber_1.toBigNumber(result.gav),
                nav: toBigNumber_1.toBigNumber(result.nav),
                feesInDenominationAsset: toBigNumber_1.toBigNumber(result.feesInDenominationAsset),
                feesInShares: toBigNumber_1.toBigNumber(result.feesInShares),
                gavPerShareNetManagementFee: toBigNumber_1.toBigNumber(result.gavPerShareNetManagementFee),
            };
        });
    }
    /**
     * Manually performs accounting calculations (GAV, NAV, share price, etc).
     *
     * @param block The block number to execute the call on.
     */
    getManualCalculationResults(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const [routes, gavFromAssets] = yield Promise.all([this.getRoutes(block), this.getGavFromAssets(block)]);
            const shares = new Shares_1.Shares(this.environment, routes.shares);
            const feeManager = new FeeManager_1.FeeManager(this.environment, routes.feeManager);
            const [mgtmFeeAmount, performanceFeeAddress, totalSupply] = yield Promise.all([
                feeManager.getManagementFeeAmount(block),
                feeManager.getFee(1, block),
                shares.getTotalSupply(block),
            ]);
            const performanceFee = new PerformanceFee_1.PerformanceFee(this.environment, performanceFeeAddress);
            const divisor = yield performanceFee.getDivisor(block);
            const [highWaterMark, perfFeeRate, gavPerShare] = yield Promise.all([
                performanceFee.getHighWaterMark(routes.feeManager, block),
                performanceFee.getPerformanceFeeRate(routes.feeManager, block),
                totalSupply.isZero()
                    ? this.getDefaultSharePrice(block)
                    : this.getValuePerShare(gavFromAssets, totalSupply, block),
            ]);
            let perfFeeAmount = new bignumber_js_1.default(0);
            if (gavPerShare.isGreaterThan(highWaterMark) && !totalSupply.isZero() && !gavFromAssets.isZero()) {
                const sharePriceGain = gavPerShare.minus(highWaterMark);
                const totalGain = sharePriceGain.multipliedBy(totalSupply).dividedBy(divisor);
                const feeInAsset = totalGain.multipliedBy(perfFeeRate).dividedBy(divisor);
                const preDilutionFee = totalSupply.multipliedBy(feeInAsset).dividedBy(gavFromAssets);
                perfFeeAmount = preDilutionFee.multipliedBy(totalSupply).dividedBy(totalSupply.minus(preDilutionFee));
            }
            const feesInShares = mgtmFeeAmount.plus(perfFeeAmount);
            const feesInDenominationAsset = totalSupply.isZero()
                ? new bignumber_js_1.default(0)
                : feesInShares.multipliedBy(gavFromAssets).dividedBy(totalSupply.plus(feesInShares));
            const nav = gavFromAssets.minus(feesInDenominationAsset);
            const totalSupplyAccountingForFees = totalSupply.plus(feesInShares);
            const [sharePrice, gavPerShareNetManagementFee] = totalSupply.isZero()
                ? yield Promise.all([this.getDefaultSharePrice(block), this.getDefaultSharePrice(block)])
                : yield Promise.all([
                    this.getValuePerShare(gavFromAssets, totalSupplyAccountingForFees, block),
                    this.getValuePerShare(gavFromAssets, totalSupply.plus(mgtmFeeAmount), block),
                ]);
            return {
                sharePrice: sharePrice.integerValue(),
                gav: gavFromAssets.integerValue(),
                nav: nav.integerValue(),
                feesInDenominationAsset: feesInDenominationAsset.integerValue(),
                feesInShares: feesInShares.integerValue(),
                gavPerShareNetManagementFee: gavPerShareNetManagementFee.integerValue(),
            };
        });
    }
    /**
     * Gets the asset GAV manually.
     *
     * @param block The block number to execute the call on.
     */
    getGavFromAssets(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const [holdings, denominationAsset, registryAddress] = yield Promise.all([
                this.getFundHoldings(block),
                this.getDenominationAsset(block),
                this.getRegistry(),
            ]);
            const registry = new Registry_1.Registry(this.environment, registryAddress);
            const priceSource = new IPriceSource_1.IPriceSource(this.environment, yield registry.getPriceSource(block));
            const assetGavs = yield Promise.all(holdings.map((holding) => {
                return !sameAddress_1.sameAddress(holding.address, denominationAsset)
                    ? priceSource.convertQuantity(holding.amount, holding.address, denominationAsset, block)
                    : holding.amount;
            }));
            const assetGav = assetGavs.reduce((acc, current) => {
                return acc.plus(current);
            }, new bignumber_js_1.default(0));
            return assetGav;
        });
    }
    /**
     * Gets the share costs in a certain asset.
     *
     * @param numShares The number of shares.
     * @param asset The requested asset.
     * @param block The block number to execute the call on.
     */
    getShareCostInAsset(numShares, asset, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('getShareCostInAsset', [numShares.toFixed(0), asset], block);
            return toBigNumber_1.toBigNumber(result);
        });
    }
    /**
     * Triggers the reward all fees function (and performs some accounting updates)
     *
     * @param from The address of the sender.
     */
    triggerRewardAllFees(from) {
        const amgu = this.calculateAmgu.bind(this);
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            const feeManager = new FeeManager_1.FeeManager(this.environment, (yield this.getRoutes()).feeManager);
            const performanceFee = new PerformanceFee_1.PerformanceFee(this.environment, yield feeManager.getPerformanceFeeAddress());
            const performanceFeeCanBePaid = yield performanceFee.canUpdate(feeManager.contract.address);
            if (!performanceFeeCanBePaid) {
                throw new PerformanceFeeCannotBePaidError();
            }
        });
        return this.createTransaction({ from, method: 'triggerRewardAllFees', amgu, validate });
    }
    /**
     * Gets the value per share.
     *
     * @param totalValue The total asset value
     * @param numShares The number of shares.
     * @param block The block number to execute the call on.
     */
    getValuePerShare(totalValue, numShares, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('valuePerShare', [totalValue.toFixed(0), numShares.toFixed(0)], block);
            return toBigNumber_1.toBigNumber(result);
        });
    }
}
exports.Accounting = Accounting;
Accounting.abi = Accounting_abi_1.AccountingAbi;
applyMixins_1.applyMixins(Accounting, [Spoke_1.Spoke, AmguConsumer_1.AmguConsumer]);
