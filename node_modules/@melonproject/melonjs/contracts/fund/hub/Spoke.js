"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Contract_1 = require("../../../Contract");
const Spoke_abi_1 = require("../../../abis/Spoke.abi");
const isZeroAddress_1 = require("../../../utils/isZeroAddress");
class Spoke extends Contract_1.Contract {
    static deploy(environment, bytecode, from, hub) {
        return super.createDeployment(environment, bytecode, from, [hub]);
    }
    /**
     * Gets the address of the engine contract.
     *
     * @param block The block number to execute the call on.
     */
    getEngine(block) {
        return this.makeCall('engine', undefined, block);
    }
    /**
     * Gets the address of the MLN token contract.
     *
     * @param block The block number to execute the call on.
     */
    getMlnToken(block) {
        return this.makeCall('mlnToken', undefined, block);
    }
    /**
     * Gets the address of the version contract.
     *
     * @param block The block number to execute the call on.
     */
    getVersion(block) {
        return this.makeCall('version', undefined, block);
    }
    /**
     * Gets the address of the registry contract.
     *
     * @param block The block number to execute the call on.
     */
    getRegistry(block) {
        return this.makeCall('registry', undefined, block);
    }
    /**
     * Gets the address of the pricesource contract.
     *
     * @param block The block number to execute the call on.
     */
    getPriceSource(block) {
        return this.makeCall('priceSource', undefined, block);
    }
    /**
     * Gets the address of the hub.
     *
     * @param block The block number to execute the call on.
     */
    getHub(block) {
        return this.makeCall('hub', undefined, block);
    }
    /**
     * Checks if the contract is initialized.
     *
     * @param block The block number to execute the call on.
     * @returns A boolean where True indicates the spoke has been initialized.
     */
    isInitialized(block) {
        return this.makeCall('initialized', undefined, block);
    }
    /**
     * Gets the routes of the hub
     *
     * @param block The block number to execute the call on.
     */
    getRoutes(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const routes = yield this.makeCall('routes', undefined, block);
            const output = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (routes.accounting && !isZeroAddress_1.isZeroAddress(routes.accounting) && { accounting: routes.accounting })), (routes.participation && !isZeroAddress_1.isZeroAddress(routes.participation) && { participation: routes.participation })), (routes.shares && !isZeroAddress_1.isZeroAddress(routes.shares) && { shares: routes.shares })), (routes.trading && !isZeroAddress_1.isZeroAddress(routes.trading) && { trading: routes.trading })), (routes.vault && !isZeroAddress_1.isZeroAddress(routes.vault) && { vault: routes.vault })), (routes.feeManager && !isZeroAddress_1.isZeroAddress(routes.feeManager) && { feeManager: routes.feeManager })), (routes.policyManager && !isZeroAddress_1.isZeroAddress(routes.policyManager) && { policyManager: routes.policyManager }));
            return output;
        });
    }
}
exports.Spoke = Spoke;
Spoke.abi = Spoke_abi_1.SpokeAbi;
