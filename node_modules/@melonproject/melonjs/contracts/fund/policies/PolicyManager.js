"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Contract_1 = require("../../../Contract");
const PolicyManager_abi_1 = require("../../../abis/PolicyManager.abi");
const Spoke_1 = require("../hub/Spoke");
const applyMixins_1 = require("../../../utils/applyMixins");
const IPolicy_1 = require("./IPolicy");
const ValidationError_1 = require("../../../errors/ValidationError");
const DSAuthority_1 = require("../../dependencies/authorization/DSAuthority");
const encodeFunctionSignature_1 = require("../../../utils/encodeFunctionSignature");
const ExchangeAdapter_abi_1 = require("../../../abis/ExchangeAdapter.abi");
const EthfinexAdapter_abi_1 = require("../../../abis/EthfinexAdapter.abi");
const Participation_abi_1 = require("../../../abis/Participation.abi");
const web3_utils_1 = require("web3-utils");
class NotAuthorizedError extends ValidationError_1.ValidationError {
    constructor(message = 'Not authorized') {
        super(message);
        this.name = 'NotAuthorizedError';
    }
}
exports.NotAuthorizedError = NotAuthorizedError;
class PolicyPositionNotPreOrPostError extends ValidationError_1.ValidationError {
    constructor(message = 'Policy position has to be pre (0) or post (1)') {
        super(message);
        this.name = 'PolicyPositionNotPreOrPostError';
    }
}
exports.PolicyPositionNotPreOrPostError = PolicyPositionNotPreOrPostError;
class ArrayLenghtsNotEqualError extends ValidationError_1.ValidationError {
    constructor(signatures, policyAddresses, message = 'Arrays do not have the same lengths') {
        super(message);
        this.signatures = signatures;
        this.policyAddresses = policyAddresses;
        this.name = 'ArrayLenghtsNotEqualError';
    }
}
exports.ArrayLenghtsNotEqualError = ArrayLenghtsNotEqualError;
class PolicyManager extends Contract_1.Contract {
    static deploy(environment, bytecode, from, hub) {
        return super.createDeployment(environment, bytecode, from, [hub]);
    }
    /**
     * Registers a policy.
     *
     * @param from The address of the sender
     * @param signature The signature of the policy
     * @param policyAddress The address of the policy
     */
    registerPolicy(from, signature, policyAddress) {
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            const hub = yield this.getHub();
            const auth = new DSAuthority_1.DSAuthority(this.environment, hub);
            const registerSignature = encodeFunctionSignature_1.encodeFunctionSignature(PolicyManager_abi_1.PolicyManagerAbi, 'register');
            const authorized = auth.canCall(hub, this.contract.address, registerSignature);
            if (!authorized) {
                throw new NotAuthorizedError();
            }
            const policy = new IPolicy_1.IPolicy(this.environment, policyAddress);
            const position = yield policy.getPosition();
            if (position !== 0 && position !== 1) {
                throw new PolicyPositionNotPreOrPostError();
            }
        });
        return this.createTransaction({
            from,
            method: 'register',
            args: [signature, policyAddress],
            validate,
        });
    }
    /**
     * Batch registers policies
     *
     * @param from The address of the sender
     * @param signatures The signatures of the policies
     * @param policyAddresss The addresses of the policies
     */
    batchRegisterPolicies(from, signatures, policyAddresses) {
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            if (signatures.length !== policyAddresses.length) {
                throw new ArrayLenghtsNotEqualError(signatures, policyAddresses);
            }
        });
        return this.createTransaction({
            from,
            method: 'batchRegister',
            args: [signatures, policyAddresses],
            validate,
        });
    }
    /**
     * Gets the policies by their signature.
     *
     * @param signature The signature of the policies
     * @param block The block number to execute the call on.
     */
    getPoliciesBySignature(signature, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('getPoliciesBySig', [signature], block);
            const policies = {
                pre: result ? result['0'] : [],
                post: result ? result['1'] : [],
            };
            return policies;
        });
    }
    /**
     * Gets a list of policies (with parameters) that are registered for a fund
     *
     * @param block The block number to execute the call on.
     */
    getPolicies(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const sigsToCheck = [
                encodeFunctionSignature_1.encodeFunctionSignature(ExchangeAdapter_abi_1.ExchangeAdapterAbi, 'makeOrder'),
                encodeFunctionSignature_1.encodeFunctionSignature(ExchangeAdapter_abi_1.ExchangeAdapterAbi, 'takeOrder'),
                encodeFunctionSignature_1.encodeFunctionSignature(ExchangeAdapter_abi_1.ExchangeAdapterAbi, 'cancelOrder'),
                encodeFunctionSignature_1.encodeFunctionSignature(EthfinexAdapter_abi_1.EthfinexAdapterAbi, 'withdrawTokens'),
                encodeFunctionSignature_1.encodeFunctionSignature(Participation_abi_1.ParticipationAbi, 'requestInvestment'),
            ];
            const retrievedPolicies = yield Promise.all(sigsToCheck.map((sig) => {
                return this.getPoliciesBySignature(sig, block);
            }));
            const policyAddresses = retrievedPolicies.map((policy) => {
                return [...policy.pre, ...policy.post];
            });
            const uniquePolicyAddresses = policyAddresses.reduce((carry, current) => {
                const add = current.filter((address) => carry.indexOf(address) === -1);
                return [...carry, ...add];
            }, []);
            const policyObjects = uniquePolicyAddresses.map((address) => __awaiter(this, void 0, void 0, function* () {
                const policy = new IPolicy_1.IPolicy(this.environment, address);
                const identifier = yield policy.getIdentifier(block);
                return {
                    address,
                    identifier,
                };
            }));
            return Promise.all(policyObjects);
        });
    }
    /**
     * Pre-validate policies (before trading)
     *
     * @param args The arguments of the policy validation function as [[PolicyValidationArgs]]
     * @param block The block number to execute the call on.
     */
    preValidate(args, block) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.makeCall('preValidate', [
                web3_utils_1.hexToBytes(args.signature),
                args.addresses,
                args.values.map((value) => value.toFixed(0)),
                web3_utils_1.hexToBytes(args.identifier),
            ], block);
        });
    }
    /**
     * Post-validate policies (before trading)
     *
     * @param args The arguments of the policy validation function as [[PolicyValidationArgs]]
     * @param block The block number to execute the call on.
     */
    postValidate(args, block) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.makeCall('postValidate', [
                web3_utils_1.hexToBytes(args.signature),
                args.addresses,
                args.values.map((value) => value.toFixed(0)),
                web3_utils_1.hexToBytes(args.identifier),
            ], block);
        });
    }
}
exports.PolicyManager = PolicyManager;
PolicyManager.abi = PolicyManager_abi_1.PolicyManagerAbi;
applyMixins_1.applyMixins(PolicyManager, [Spoke_1.Spoke]);
