"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Contract_1 = require("../../../Contract");
const Trading_abi_1 = require("../../../abis/Trading.abi");
const Spoke_1 = require("../hub/Spoke");
const applyMixins_1 = require("../../../utils/applyMixins");
const toBigNumber_1 = require("../../../utils/toBigNumber");
const Registry_1 = require("../../version/Registry");
const isZeroAddress_1 = require("../../../utils/isZeroAddress");
const web3_utils_1 = require("web3-utils");
const functionSignature_1 = require("../../../utils/functionSignature");
const ExchangeAdapter_abi_1 = require("../../../abis/ExchangeAdapter.abi");
const Trading_errors_1 = require("./Trading.errors");
const PolicyManager_1 = require("../policies/PolicyManager");
const toDate_1 = require("../../../utils/toDate");
const Registry_error_1 = require("../../version/Registry.error");
const sameAddress_1 = require("../../../utils/sameAddress");
const Hub_1 = require("../hub/Hub");
var OrderUpdateType;
(function (OrderUpdateType) {
    OrderUpdateType[OrderUpdateType["make"] = 0] = "make";
    OrderUpdateType[OrderUpdateType["take"] = 1] = "take";
    OrderUpdateType[OrderUpdateType["cancel"] = 2] = "cancel";
})(OrderUpdateType = exports.OrderUpdateType || (exports.OrderUpdateType = {}));
class Trading extends Contract_1.Contract {
    static deploy(environment, bytecode, from, args) {
        return super.createDeployment(environment, bytecode, from, [
            args.hub,
            args.exchanges,
            args.adapters,
            args.registry,
        ]);
    }
    /**
     * Checks if an adapter is already added
     *
     * @param adapter The address of the adapter
     * @param block: The block number
     */
    adapterIsAdded(adapter, block) {
        return this.makeCall('adapterIsAdded', [adapter], block);
    }
    /**
     * Add an exchange for a fund
     *
     * @param from The address of the sender.
     * @param exchange The address of the exchange
     * @param adapter The address of the adapter
     */
    addExchange(from, exchange, adapter) {
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            if (yield this.adapterIsAdded(adapter)) {
                throw new Trading_errors_1.AdapterIsAlreadyAddedError(adapter);
            }
            const registry = new Registry_1.Registry(this.environment, yield this.getRegistry());
            if (!(yield registry.isExchangeAdapterRegistered(adapter))) {
                throw new Registry_error_1.ExchangeAdapterNotRegisteredError(adapter);
            }
            const exchangeInfo = registry.getExchangeInformation(adapter);
            if (!sameAddress_1.sameAddress((yield exchangeInfo).exchangeAddress, exchange)) {
                throw new Registry_error_1.ExchangeAndAdapterDoNotMatchError(exchange, adapter);
            }
        });
        return this.createTransaction({ from, method: 'addExchange', args: [exchange, adapter], validate });
    }
    /**
     * Returns assets from trading to vaut.
     *
     * @param from The address of the sender.
     * @param assets The addresses of the assets to return to vault.
     */
    returnBatchToVault(from, assets) {
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            const hub = new Hub_1.Hub(this.environment, yield this.getHub());
            if (!(sameAddress_1.sameAddress(from, this.contract.address) ||
                sameAddress_1.sameAddress(from, yield hub.getManager()) ||
                (yield hub.isShutDown()))) {
                throw new Trading_errors_1.SenderIsNotManagerOrContractError(from);
            }
        });
        return this.createTransaction({ from, method: 'returnBatchToVault', args: [assets], validate });
    }
    /**
     * Gets information on all exchanges.
     *
     * @param block The block number to execute the call on.
     */
    getExchangeInfo(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const { '0': ofExchanges, '1': ofAdapters, '2': takesCustody } = yield this.makeCall('getExchangeInfo', undefined, block);
            const output = ofExchanges.map((_, index) => ({
                exchange: ofExchanges[index],
                adapter: ofAdapters[index],
                takesCustody: takesCustody[index],
            }));
            return output;
        });
    }
    /**
     * Gets information for a single exchange
     *
     * @param index The index of the exchange
     * @param block The block number to execute the call on.
     */
    getExchange(index, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const { '0': exchange, '1': adapter, '2': takesCustody } = yield this.makeCall('exchanges', [index], block);
            return { exchange, adapter, takesCustody };
        });
    }
    /**
     * Get the details of an open make order.
     *
     * @param exchange The address of the exchange
     * @param asset The address of the asset
     * @param block The block number to execute the call on.
     */
    getOpenMakeOrder(exchange, asset, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('exchangesToOpenMakeOrders', [exchange, asset], block);
            return {
                id: toBigNumber_1.toBigNumber(result.id),
                expiresAt: new Date(parseInt(`${result.expiresAt}`, 10) * 1000),
                orderIndex: toBigNumber_1.toBigNumber(result.orderIndex),
                buyAsset: result.buyAsset,
            };
        });
    }
    /**
     * Get all open make orders.
     *
     * @param block The block number to execute the call on.
     */
    getOpenMakeOrders(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const [exchangeInfo, registryAddress] = yield Promise.all([this.getExchangeInfo(block), this.getRegistry(block)]);
            const registry = new Registry_1.Registry(this.environment, registryAddress);
            const assets = yield registry.getRegisteredAssets(block);
            const exchanges = exchangeInfo.map((exchange) => exchange.exchange);
            const possibilities = [].concat.apply([], exchanges.map((exchange) => assets.map((asset) => [exchange, asset])));
            const openOrders = yield Promise.all(possibilities.map(([exchange, asset]) => __awaiter(this, void 0, void 0, function* () {
                const order = yield this.getOpenMakeOrder(exchange, asset, block);
                return Object.assign(Object.assign({}, order), { exchange });
            })));
            return openOrders.filter((o) => !isZeroAddress_1.isZeroAddress(o.buyAsset));
        });
    }
    /**
     * Get the details of an order.
     *
     * @param index The index of the order
     * @param block The block number to execute the call on.
     */
    getOrderDetails(index, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const details = yield this.makeCall('getOrderDetails', [index.toFixed(0)], block);
            if (!details) {
                return null;
            }
            const { '0': makerAsset, '1': takerAsset, '2': makerQuantity, '3': takerQuantity } = details;
            return {
                makerAsset,
                takerAsset,
                makerQuantity: toBigNumber_1.toBigNumber(makerQuantity),
                takerQuantity: toBigNumber_1.toBigNumber(takerQuantity),
            };
        });
    }
    /**
     * Checks if an order is expired.
     *
     * @param exchange The address of the exchange
     * @param asset The address of the asset
     * @param block The block number to execute the call on.
     */
    isOrderExpired(exchange, asset, block) {
        return this.makeCall('isOrderExpired', [exchange, asset], block);
    }
    /**
     * Gets the order lifespan.
     *
     * @param block The block number to execute the call on.
     */
    getOrderLifespan(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('ORDER_LIFESPAN', undefined, block);
            return toBigNumber_1.toBigNumber(result);
        });
    }
    validateCallOnExchange(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const registry = new Registry_1.Registry(this.environment, yield this.getRegistry());
            const exchange = yield this.getExchange(args.exchangeIndex);
            if (!exchange) {
                throw new Trading_errors_1.InvalidExchangeIndexError(args.exchangeIndex);
            }
            const encodedSignature = web3_utils_1.keccak256(args.methodSignature).substr(0, 10);
            const adapterMethodIsAllowed = yield registry.isAdapterMethodAllowed(exchange.adapter, encodedSignature);
            if (!adapterMethodIsAllowed) {
                throw new Trading_errors_1.AdapterMethodNotAllowedError(exchange.adapter, encodedSignature);
            }
            const makeOrderSignature = functionSignature_1.functionSignature(ExchangeAdapter_abi_1.ExchangeAdapterAbi, 'makeOrder');
            const takeOrderSignature = functionSignature_1.functionSignature(ExchangeAdapter_abi_1.ExchangeAdapterAbi, 'takeOrder');
            if (args.methodSignature === makeOrderSignature || args.methodSignature === takeOrderSignature) {
                const makerAssetIsRegistered = yield registry.isAssetRegistered(args.orderAddresses[2]);
                if (!makerAssetIsRegistered) {
                    throw new Registry_error_1.AssetNotRegisteredError(args.orderAddresses[2]);
                }
                const takerAssetIsRegistered = yield registry.isAssetRegistered(args.orderAddresses[3]);
                if (!takerAssetIsRegistered) {
                    throw new Registry_error_1.AssetNotRegisteredError(args.orderAddresses[3]);
                }
            }
            const policyManagerAddress = (yield this.getRoutes()).policyManager;
            const policyManager = new PolicyManager_1.PolicyManager(this.environment, policyManagerAddress);
            const exchangeAddress = exchange.exchange;
            const validationArgs = {
                signature: encodedSignature,
                addresses: [
                    args.orderAddresses[0],
                    args.orderAddresses[1],
                    args.orderAddresses[2],
                    args.orderAddresses[3],
                    exchangeAddress,
                ],
                values: [args.orderValues[0], args.orderValues[1], args.orderValues[6]],
                identifier: args.identifier,
            };
            try {
                yield Promise.all([policyManager.preValidate(validationArgs), policyManager.postValidate(validationArgs)]);
            }
            catch (e) {
                throw new Trading_errors_1.TradePolicyValidationError(encodedSignature);
            }
        });
    }
    /**
     * Call on exchange (all trading transactions go through this).
     *
     * @param from The address of the sender
     * @param args The arguments as [[CallOnExchangeArgs]]
     * @param validation An additional async validation function
     */
    callOnExchange(from, args, validationFunction) {
        const methodArgs = [
            args.exchangeIndex.toFixed(0),
            args.methodSignature,
            args.orderAddresses,
            args.orderValues.map((orderValue) => orderValue.toFixed(0)),
            args.orderData,
            args.identifier,
            web3_utils_1.hexToBytes(args.signature),
        ];
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            yield this.validateCallOnExchange(args);
            if (typeof validationFunction === 'function') {
                yield validationFunction();
            }
        });
        return this.createTransaction({ from, method: 'callOnExchange', args: methodArgs, validate });
    }
    /**
     * Update and get quantity being traded
     *
     * @param asset The address of the asset
     * @param block The block number to execute the call on.
     */
    updateAndGetQuantityBeingTraded(asset, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('updateAndGetQuantityBeingTraded', [asset], block);
            return toBigNumber_1.toBigNumber(result);
        });
    }
    /**
     * Update and get quantity being traded
     *
     * @param asset The address of the asset
     * @param block The block number to execute the call on.
     */
    sendUpdateAndGetQuantityBeingTraded(from, asset, block) {
        return this.createTransaction({ from, method: 'updateAndGetQuantityBeingTraded', args: [asset] });
    }
    /**
     * Update and get quantity held in exchanges
     *
     * @param asset The address of the asset
     * @param block The block number to execute the call on.
     */
    updateAndGetQuantityHeldInExchange(asset, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('updateAndGetQuantityHeldInExchange', [asset], block);
            return toBigNumber_1.toBigNumber(result);
        });
    }
    /**
     * Update and get quantity held in exchanges
     *
     * @param identifier The identifier of the order
     * @param block The block number to execute the call on.
     */
    getZeroExOrderDetails(identifier, block) {
        return this.makeCall('getZeroExOrderDetails', [web3_utils_1.numberToHex(identifier.toFixed(0))], block);
    }
    /**
     * Check if there is an open make order for a certain asset
     *
     * @param asset The address of the asset
     * @param block The block number to execute the call on.
     */
    checkOpenMakeOrder(asset, block) {
        return this.makeCall('isInOpenMakeOrder', [asset], block);
    }
    /**
     * Get maker asset cooldown time
     *
     * @param asset The address of the asset
     * @param block The block number to execute the call on.
     */
    getMakerAssetCooldown(asset, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('makerAssetCooldown', [asset], block);
            if (toBigNumber_1.toBigNumber(result).isZero()) {
                return;
            }
            return toDate_1.toDate(result);
        });
    }
}
exports.Trading = Trading;
Trading.abi = Trading_abi_1.TradingAbi;
applyMixins_1.applyMixins(Trading, [Spoke_1.Spoke]);
