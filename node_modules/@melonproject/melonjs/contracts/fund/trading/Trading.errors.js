"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ValidationError_1 = require("../../../errors/ValidationError");
class ExchangeNotRegisteredWithFundError extends ValidationError_1.ValidationError {
    constructor(kyberAddress, message = 'Exchange is not registered for this fund.') {
        super(message);
        this.kyberAddress = kyberAddress;
        this.name = 'ExchangeNotRegisteredWithFundError';
    }
}
exports.ExchangeNotRegisteredWithFundError = ExchangeNotRegisteredWithFundError;
class FundIsShutDownError extends ValidationError_1.ValidationError {
    constructor(fund, message = 'Fund is shutdown.') {
        super(message);
        this.fund = fund;
        this.name = 'FundIsShutDownError';
    }
}
exports.FundIsShutDownError = FundIsShutDownError;
class AdapterIsAlreadyAddedError extends ValidationError_1.ValidationError {
    constructor(adapter, message = 'Adapter is already added.') {
        super(message);
        this.adapter = adapter;
        this.name = 'AdapterIsAlreadyAddedError';
    }
}
exports.AdapterIsAlreadyAddedError = AdapterIsAlreadyAddedError;
class AdapterMethodNotAllowedError extends ValidationError_1.ValidationError {
    constructor(adapter, signature, message = 'Adapter Method is not allowed.') {
        super(message);
        this.adapter = adapter;
        this.signature = signature;
        this.name = 'AdapterMethodNotAllowedError';
    }
}
exports.AdapterMethodNotAllowedError = AdapterMethodNotAllowedError;
class InsufficientBalanceError extends ValidationError_1.ValidationError {
    constructor(requested, actual, message = 'Insufficient balance.') {
        super(message);
        this.requested = requested;
        this.actual = actual;
        this.name = 'InsufficientBalanceError';
    }
}
exports.InsufficientBalanceError = InsufficientBalanceError;
class InvalidExchangeIndexError extends ValidationError_1.ValidationError {
    constructor(index, message = 'Invalid exchange index.') {
        super(message);
        this.index = index;
        this.name = 'InvalidExchangeIndexError';
    }
}
exports.InvalidExchangeIndexError = InvalidExchangeIndexError;
class SenderIsNotFundManagerError extends ValidationError_1.ValidationError {
    constructor(sender, message = 'Only the manager can call this function.') {
        super(message);
        this.sender = sender;
        this.name = 'SenderIsNotFundManagerError';
    }
}
exports.SenderIsNotFundManagerError = SenderIsNotFundManagerError;
class SenderIsNotManagerOrContractError extends ValidationError_1.ValidationError {
    constructor(sender, message = 'Only the manager can call this function.') {
        super(message);
        this.sender = sender;
        this.name = 'SenderIsNotManagerOrContractError';
    }
}
exports.SenderIsNotManagerOrContractError = SenderIsNotManagerOrContractError;
class TradePolicyValidationError extends ValidationError_1.ValidationError {
    constructor(signature, message = 'Trade cannot be executed because risk management policies or compliance policies would be violated.') {
        super(message);
        this.signature = signature;
        this.name = 'TradePolicyValidationError';
    }
}
exports.TradePolicyValidationError = TradePolicyValidationError;
class AssetAlreadyHasOpenMakeOrderError extends ValidationError_1.ValidationError {
    constructor(asset, message = 'There is already an open make order for this asset.') {
        super(message);
        this.asset = asset;
        this.name = 'AssetAlreadyHasOpenMakeOrderError';
    }
}
exports.AssetAlreadyHasOpenMakeOrderError = AssetAlreadyHasOpenMakeOrderError;
class CooldownForMakerAssetNotReachedError extends ValidationError_1.ValidationError {
    constructor(asset, message = 'Cooldown for the maker asset not reached yet.') {
        super(message);
        this.asset = asset;
        this.name = 'CooldownForMakerAssetNotReachedError';
    }
}
exports.CooldownForMakerAssetNotReachedError = CooldownForMakerAssetNotReachedError;
