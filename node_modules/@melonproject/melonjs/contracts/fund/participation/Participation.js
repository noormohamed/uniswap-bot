"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const Contract_1 = require("../../../Contract");
const Participation_abi_1 = require("../../../abis/Participation.abi");
const Spoke_1 = require("../hub/Spoke");
const applyMixins_1 = require("../../../utils/applyMixins");
const toBigNumber_1 = require("../../../utils/toBigNumber");
const toDate_1 = require("../../../utils/toDate");
const AmguConsumer_1 = require("../../engine/AmguConsumer");
const Hub_1 = require("../hub/Hub");
const HubIsShutdownError_1 = require("../../../errors/HubIsShutdownError");
const SpokeNotInitializedError_1 = require("../../../errors/SpokeNotInitializedError");
const IPriceSource_1 = require("../../prices/IPriceSource");
const Accounting_1 = require("../accounting/Accounting");
const Shares_1 = require("../shares/Shares");
const Registry_1 = require("../../version/Registry");
const sameAddress_1 = require("../../../utils/sameAddress");
const web3_utils_1 = require("web3-utils");
const functionSignature_1 = require("../../../utils/functionSignature");
const PolicyManager_1 = require("../policies/PolicyManager");
const zeroAddress_1 = require("../../../utils/zeroAddress");
const zeroBigNumber_1 = require("../../../utils/zeroBigNumber");
const OutOfBalanceError_1 = require("../../../errors/OutOfBalanceError");
const InsufficientAllowanceError_1 = require("../../../errors/InsufficientAllowanceError");
const ERC20WithFields_1 = require("../../dependencies/token/ERC20WithFields");
const Participation_errors_1 = require("./Participation.errors");
class Participation extends Contract_1.Contract {
    constructor() {
        super(...arguments);
        /**
         * Validate if a request can be cancelled
         *
         * @param investor The address of the investor.
         */
        this.validateCancelRequest = (investor, block) => __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.hasRequest(investor, block))) {
                throw new Participation_errors_1.NoInvestmentRequestError(investor);
            }
            const request = yield this.getRequest(investor, block);
            const hub = new Hub_1.Hub(this.environment, yield this.getHub(block));
            const priceSource = new IPriceSource_1.IPriceSource(this.environment, yield this.getPriceSource(block));
            if (!(!(yield priceSource.hasValidPrice(request.investmentAsset, block)) ||
                (yield this.hasExpiredRequest(investor, block)) ||
                (yield hub.isShutDown(block)))) {
                throw new Participation_errors_1.CancelConditionsNotMetError(investor);
            }
        });
    }
    static deploy(environment, bytecode, from, args) {
        return super.createDeployment(environment, bytecode, from, [
            args.hub,
            args.defaultAssets,
            args.registry,
        ]);
    }
    /**
     * Gets a list of all historical investors.
     *
     * @param block The block number to execute the call on.
     */
    getHistoricalInvestors(block) {
        return this.makeCall('getHistoricalInvestors', undefined, block);
    }
    /**
     * Enable investment for a list of assets
     *
     * @param from The address of the sender.
     * @param assets The addresses of the assets
     */
    enableInvestment(from, assets) {
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            const registry = new Registry_1.Registry(this.environment, yield this.getRegistry());
            const registeredAssets = yield registry.getRegisteredAssets();
            assets.map((asset) => {
                const assetIsRegistered = registeredAssets.some((registered) => sameAddress_1.sameAddress(registered, asset));
                if (!assetIsRegistered) {
                    throw new Participation_errors_1.AssetIsNotRegisteredError(asset);
                }
            });
        });
        return this.createTransaction({ from, method: 'enableInvestment', args: [assets], validate });
    }
    /**
     * Disable investment for a list of assets
     *
     * @param from The address of the sender.
     * @param assets The addresses of the assets
     */
    disableInvestment(from, assets) {
        return this.createTransaction({ from, method: 'disableInvestment', args: [assets] });
    }
    /**
     * Gets the details of a request.
     *
     * @param investor The address of the investor
     * @param block The block number to execute the call on.
     */
    getRequest(investor, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('requests', [investor], block);
            if (!result || `${result.timestamp}` === '0') {
                return undefined;
            }
            return {
                investmentAsset: result.investmentAsset,
                investmentAmount: toBigNumber_1.toBigNumber(result.investmentAmount),
                requestedShares: toBigNumber_1.toBigNumber(result.requestedShares),
                timestamp: toDate_1.toDate(result.timestamp),
            };
        });
    }
    /**
     * Checks if an investor has a request.
     *
     * @param investor The address of the investor
     * @param block The block number to execute the call on.
     */
    hasRequest(investor, block) {
        return this.makeCall('hasRequest', [investor], block);
    }
    /**
     * Checks if an investor has a valid request.
     *
     * @param investor The address of the investor
     * @param block The block number to execute the call on.
     */
    hasValidRequest(investor, block) {
        return this.makeCall('hasValidRequest', [investor], block);
    }
    /**
     * Checks if an investor has an expired request.
     *
     * @param investor The address of the investor
     * @param block The block number to execute the call on.
     */
    hasExpiredRequest(investor, block) {
        return this.makeCall('hasExpiredRequest', [investor], block);
    }
    /**
     * Checks if an investor already has invested.
     *
     * @param investor The address of the investor
     * @param block The block number to execute the call on.
     */
    hasInvested(investor, block) {
        return this.makeCall('hasInvested', [investor], block);
    }
    /**
     * Checks if an investement into the fund with a certain asset is allowed
     *
     * @param investor The address of the investor
     * @param block The block number to execute the call on.
     */
    canInvestWithAsset(asset, block) {
        return this.makeCall('investAllowed', [asset], block);
    }
    /**
     * Request investment.
     *
     * @param from The address of the sender.
     * @param sharesAmount The number of shares requested
     * @param investmentAmount The amount to be invested
     * @param investmentAsset The address of the investment asset
     */
    requestInvestment(from, sharesAmount, investmentAmount, investmentAsset) {
        const amgu = this.calculateAmgu.bind(this);
        const incentive = () => Promise.resolve(new bignumber_js_1.default(10).exponentiatedBy(16));
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            const initialized = yield this.isInitialized();
            if (!initialized) {
                throw new SpokeNotInitializedError_1.SpokeNotInitializedError(this.contract.address);
            }
            const hub = new Hub_1.Hub(this.environment, yield this.getHub());
            if (yield hub.isShutDown()) {
                throw new HubIsShutdownError_1.HubIsShutdownError(hub.contract.address);
            }
            const encodedSignature = web3_utils_1.keccak256(functionSignature_1.functionSignature(Participation_abi_1.ParticipationAbi, 'requestInvestment')).substr(0, 10);
            const policyManagerAddress = (yield this.getRoutes()).policyManager;
            const policyManager = new PolicyManager_1.PolicyManager(this.environment, policyManagerAddress);
            const validationArgs = {
                signature: encodedSignature,
                addresses: [from, zeroAddress_1.zeroAddress, zeroAddress_1.zeroAddress, investmentAsset, zeroAddress_1.zeroAddress],
                values: [zeroBigNumber_1.zeroBigNumber, zeroBigNumber_1.zeroBigNumber, zeroBigNumber_1.zeroBigNumber],
                identifier: web3_utils_1.padLeft('0x0', 64),
            };
            try {
                yield Promise.all([policyManager.preValidate(validationArgs), policyManager.postValidate(validationArgs)]);
            }
            catch (e) {
                throw new Participation_errors_1.InvestmentPolicyValidationError(encodedSignature);
            }
            if (!(yield this.canInvestWithAsset(investmentAsset))) {
                throw new Participation_errors_1.InvestmentAssetNotAllowedError(investmentAsset);
            }
            const request = yield this.getRequest(from);
            if (typeof request !== 'undefined') {
                throw new Participation_errors_1.InvestmentRequestExistsError(request);
            }
            const token = new ERC20WithFields_1.ERC20WithFields(this.environment, investmentAsset);
            const balance = yield token.getBalanceOf(from);
            if (balance.isLessThan(investmentAmount)) {
                throw new OutOfBalanceError_1.OutOfBalanceError(investmentAmount, balance);
            }
            const allowance = yield token.getAllowance(from, this.contract.address);
            if (allowance.isLessThan(investmentAmount)) {
                throw new InsufficientAllowanceError_1.InsufficientAllowanceError(investmentAmount, allowance);
            }
        });
        const args = [sharesAmount.toFixed(0), investmentAmount.toFixed(0), investmentAsset];
        return this.createTransaction({ from, method: 'requestInvestment', args, validate, amgu, incentive });
    }
    /**
     * Execute investment request for an investor
     *
     * @param from The address of the sender.
     * @param investor The address of the investor
     */
    executeRequestFor(from, investor) {
        const amgu = this.calculateAmgu.bind(this);
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.hasRequest(investor))) {
                throw new Participation_errors_1.NoInvestmentRequestError(investor);
            }
            const request = yield this.getRequest(investor);
            const priceSource = new IPriceSource_1.IPriceSource(this.environment, yield this.getPriceSource());
            if (!(yield priceSource.hasValidPrice(request.investmentAsset))) {
                throw new Participation_errors_1.PriceNotValidError(request.investmentAsset);
            }
            const accounting = new Accounting_1.Accounting(this.environment, (yield this.getRoutes()).accounting);
            const totalShareCostInInvestmentAsset = yield accounting.getShareCostInAsset(request.requestedShares, request.investmentAsset);
            if (totalShareCostInInvestmentAsset.isGreaterThan(request.investmentAmount)) {
                throw new Participation_errors_1.InvestmentAmountTooLowError(request.investmentAmount);
            }
        });
        return this.createTransaction({
            from,
            method: 'executeRequestFor',
            args: [investor],
            validate,
            amgu,
        });
    }
    /**
     * Execute investment request
     *
     * @param from The address of the sender.
     */
    executeRequest(from) {
        return this.executeRequestFor(from, from);
    }
    /**
     * Check if a request can be cancelled
     *
     * @param from The address of the sender.
     */
    canCancelRequest(from, block) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.validateCancelRequest(from, block);
                return true;
            }
            catch (e) {
                return false;
            }
        });
    }
    /**
     * Cancel investment request for investor
     *
     * @param from The address of the sender.
     * @param investor The address of the investor
     *
     */
    cancelRequestFor(from, investor) {
        const amgu = this.calculateAmgu.bind(this);
        const validate = () => this.validateCancelRequest(investor);
        return this.createTransaction({
            from,
            method: 'cancelRequestFor',
            args: [investor],
            validate,
            amgu,
        });
    }
    /**
     * Cancel investment request
     *
     * @param from The address of the sender.
     *
     */
    cancelRequest(from) {
        return this.cancelRequestFor(from, from);
    }
    /**
     * Redeem all shares
     *
     * @param from The address of the sender.
     */
    redeem(from) {
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            const shares = new Shares_1.Shares(this.environment, (yield this.getRoutes()).shares);
            const ownedShares = yield shares.getBalanceOf(from);
            if (ownedShares.isZero()) {
                throw new Participation_errors_1.NoSharesToRedeemError();
            }
        });
        return this.createTransaction({
            from,
            method: 'redeem',
            args: undefined,
            validate,
        });
    }
    /**
     * Redeem a quantity of shares
     *
     * @param from The address of the sender.
     * @param shareQuantity The quantity of shares to redeem
     */
    redeemQuantity(from, shareQuantity) {
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            const shares = new Shares_1.Shares(this.environment, (yield this.getRoutes()).shares);
            const ownedShares = yield shares.getBalanceOf(from);
            if (ownedShares.isZero()) {
                throw new Participation_errors_1.NoSharesToRedeemError(from);
            }
            if (ownedShares.isLessThan(shareQuantity)) {
                throw new Participation_errors_1.NotEnoughSharesToRedeemError(ownedShares);
            }
        });
        return this.createTransaction({
            from,
            method: 'redeemQuantity',
            args: [shareQuantity.toFixed(0)],
            validate,
        });
    }
}
exports.Participation = Participation;
Participation.abi = Participation_abi_1.ParticipationAbi;
applyMixins_1.applyMixins(Participation, [Spoke_1.Spoke, AmguConsumer_1.AmguConsumer]);
