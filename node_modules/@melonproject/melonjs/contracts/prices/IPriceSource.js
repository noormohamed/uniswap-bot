"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Contract_1 = require("../../Contract");
const toDate_1 = require("../../utils/toDate");
const toBigNumber_1 = require("../../utils/toBigNumber");
const CallError_1 = require("../../errors/CallError");
const IPriceSource_abi_1 = require("../../abis/IPriceSource.abi");
class InvalidPriceError extends CallError_1.CallError {
    constructor(token, message = 'Invalid price.') {
        super(message);
        this.token = token;
        this.name = 'InvalidPriceError';
    }
}
exports.InvalidPriceError = InvalidPriceError;
class IPriceSource extends Contract_1.Contract {
    /**
     * Gets the quote asset of the price feed.
     *
     * @param block The block number to execute the call on.
     */
    getQuoteAsset(block) {
        return this.makeCall('getQuoteAsset', undefined, block);
    }
    /**
     * Gets the last update of the price feed.
     *
     * @param block The block number to execute the call on.
     */
    getLastUpdate(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('getLastUpdate', undefined, block);
            return result && toDate_1.toDate(result);
        });
    }
    /**
     * Checks if the price of a token is valid.
     *
     * @param tokenAddress The address of the token.
     * @param block The block number to execute the call on.
     */
    hasValidPrice(tokenAddress, block) {
        return this.makeCall('hasValidPrice', [tokenAddress], block);
    }
    /**
     * Checks if the prices of an array of tokens is valid.
     *
     * @param tokenAddresses The addresses of the tokens.
     * @param block The block number to execute the call on.
     */
    hasValidPrices(tokenAddresses, block) {
        return this.makeCall('hasValidPrices', [tokenAddresses], block);
    }
    /**
     * Gets the price of a token.
     *
     * @param token The address of the base token.
     * @param block The block number to execute the call on.
     */
    getPrice(token, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('getPrice', [token], block);
            if (!result) {
                throw new InvalidPriceError(token);
            }
            const { '0': price, '1': timestamp } = result;
            const output = {
                price: toBigNumber_1.toBigNumber(price),
                timestamp: toDate_1.toDate(timestamp),
            };
            return output;
        });
    }
    /**
     * Gets the prices of multiple tokens.
     *
     * @param tokens The addresses of the base tokens.
     * @param block The block number to execute the call on.
     */
    getPrices(tokens, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('getPrices', [tokens], block);
            const { '0': prices, '1': timestamps } = result;
            return tokens.reduce((carry, token, index) => {
                const item = {
                    price: toBigNumber_1.toBigNumber(prices[index]),
                    timestamp: toDate_1.toDate(timestamps[index]),
                };
                return [...carry, item];
            }, []);
        });
    }
    /**
     * Gets the price info of a token
     *
     * @param token The addresses of the base tokens.
     * @param block The block number to execute the call on.
     */
    getPriceInfo(token, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('getPriceInfo', [token], block);
            const { '0': price, '1': decimals } = result;
            return {
                price: toBigNumber_1.toBigNumber(price),
                decimals: parseInt(decimals, 10),
            };
        });
    }
    /**
     * Gets the inverted price info of a token
     *
     * @param token The addresses of the base tokens.
     * @param block The block number to execute the call on.
     */
    getInvertedPriceInfo(token, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('getInvertedPriceInfo', [token], block);
            const { '0': price, '1': decimals } = result;
            return {
                price: toBigNumber_1.toBigNumber(price),
                decimals: parseInt(decimals, 10),
            };
        });
    }
    /**
     * Gets the reference price information
     *
     * @param base The address of the base token.
     * @param quote The address of the quote token
     * @param block The block number to execute the call on.
     */
    getReferencePriceInfo(base, quote, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('getReferencePriceInfo', [base, quote], block);
            const { '0': price, '1': decimals } = result;
            return {
                price: toBigNumber_1.toBigNumber(price),
                decimals: parseInt(decimals, 10),
            };
        });
    }
    /**
     * Gets the order price information
     *
     * @param sellAsset The address of the sell asset.
     * @param sellQuantity The quantity of the sell asset
     * @param buyQuantity The quantity of the buy asset
     * @param block The block number to execute the call on.
     */
    getOrderPriceInfo(sellAsset, sellQuantity, buyQuantity, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('getOrderPriceInfo', [sellAsset, sellQuantity.toFixed(0), buyQuantity.toFixed(0)], block);
            return toBigNumber_1.toBigNumber(result);
        });
    }
    /**
     * Checks whether a price exists on an asset pair
     *
     * @param sellAsset The address of the sell asset.
     * @param buyAsset The address of the buy asset
     * @param block The block number to execute the call on.
     */
    existsPriceOnAssetPair(sellAsset, buyAsset, block) {
        return this.makeCall('existsPriceOnAssetPair', [sellAsset, buyAsset], block);
    }
    /**
     * Checks whether a price exists on an asset pair
     *
     * @param sellAsset The address of the sell asset.
     * @param buyAsset The address of the buy asset
     * @param block The block number to execute the call on.
     */
    convertQuantity(fromAssetQuantity, fromAsset, toAsset, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('convertQuantity', [fromAssetQuantity.toFixed(0), fromAsset, toAsset], block);
            return toBigNumber_1.toBigNumber(result);
        });
    }
}
exports.IPriceSource = IPriceSource;
IPriceSource.abi = IPriceSource_abi_1.IPriceSourceAbi;
