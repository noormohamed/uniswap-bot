"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Registry_error_1 = require("./Registry.error");
const createTestEnvironment_1 = require("../../utils/tests/createTestEnvironment");
const deployRegistry_1 = require("../../utils/tests/deployRegistry");
const randomAddress_1 = require("../../utils/tests/randomAddress");
const deployWeth_1 = require("../../utils/tests/deployWeth");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const sameAddress_1 = require("../../utils/sameAddress");
describe('Registry', () => {
    let environment;
    let registry;
    beforeAll(() => __awaiter(void 0, void 0, void 0, function* () {
        environment = yield createTestEnvironment_1.createTestEnvironment();
        registry = yield deployRegistry_1.deployRegistry(environment, environment.accounts[0], environment.accounts[0]);
    }));
    it('should return the registered versions', () => __awaiter(void 0, void 0, void 0, function* () {
        const result = yield registry.getRegisteredVersions();
        expect(result.length).toBeGreaterThanOrEqual(0);
    }));
    it('should check wether a version name already exists', () => __awaiter(void 0, void 0, void 0, function* () {
        const result = yield registry.versionNameExists('test-version');
        expect(result).toBe(false);
    }));
    it('should register fees and check if they were indeed registered', () => __awaiter(void 0, void 0, void 0, function* () {
        const [managementFeeAdress, performanceFeeAddress] = [randomAddress_1.randomAddress(), randomAddress_1.randomAddress()];
        const tx = yield registry.registerFees(environment.accounts[0], [managementFeeAdress, performanceFeeAddress]);
        yield tx.send(yield tx.prepare());
        {
            const result = yield registry.isFeeRegistered(managementFeeAdress);
            expect(result).toBe(true);
        }
        {
            const result = yield registry.isFeeRegistered(performanceFeeAddress);
            expect(result).toBe(true);
        }
    }));
    it('should register an asset and check if it was indeed registered', () => __awaiter(void 0, void 0, void 0, function* () {
        const weth = yield deployWeth_1.deployWeth(environment, environment.accounts[0]);
        const tx = yield registry.registerAsset(environment.accounts[0], {
            address: weth.contract.address,
            name: 'Test Asset',
            symbol: 'TAT',
            url: 'https://tat.tat/',
            reserveMin: new bignumber_js_1.default(100000),
            standards: [1, 2, 3],
            sigs: ['0x79705be7'],
        });
        yield tx.send(yield tx.prepare());
        const result = yield registry.getAssetInformation(weth.contract.address);
        expect(result.exists).toBe(true);
    }));
    it('should register an exchange adapter and check if it was indeed registered', () => __awaiter(void 0, void 0, void 0, function* () {
        const exchangeAddress = randomAddress_1.randomAddress();
        const adapterAddress = randomAddress_1.randomAddress();
        const tx = yield registry.registerExchangeAdapter(environment.accounts[0], {
            exchangeAddress,
            adapterAddress,
            takesCustody: true,
            sigs: ['0x79705be7'],
        });
        yield tx.send(yield tx.prepare());
        const result = yield registry.isExchangeAdapterRegistered(adapterAddress);
        expect(typeof result).toBe('boolean');
    }));
    it('should throw ExchangeAdapterAlreadyRegisteredError', () => __awaiter(void 0, void 0, void 0, function* () {
        const tx = registry.registerExchangeAdapter('', {
            exchangeAddress: '',
            adapterAddress: '',
            takesCustody: true,
            sigs: [],
        });
        jest.spyOn(registry, 'getExchangeInformation').mockReturnValue(new Promise((resolve) => resolve({
            exists: true,
            exchangeAddress: '',
            takesCustody: true,
            sigs: [],
        })));
        jest
            .spyOn(registry, 'getRegisteredExchangeAdapters')
            .mockReturnValue(new Promise((resolve) => resolve([undefined])));
        jest
            .spyOn(registry, 'getMaxRegisteredEntities')
            .mockReturnValue(new Promise((resolve) => resolve(new bignumber_js_1.default(2))));
        yield expect(tx.validate()).rejects.toThrowError(Registry_error_1.ExchangeAdapterAlreadyRegisteredError);
    }));
    it('should throw ExchangeAdaptersRegisteredOutOfBoundsError', () => __awaiter(void 0, void 0, void 0, function* () {
        const tx = registry.registerExchangeAdapter('', {
            exchangeAddress: '',
            adapterAddress: '',
            takesCustody: true,
            sigs: [],
        });
        jest.spyOn(registry, 'getExchangeInformation').mockReturnValue(new Promise((resolve) => resolve({
            exists: false,
            exchangeAddress: '',
            takesCustody: true,
            sigs: [],
        })));
        jest
            .spyOn(registry, 'getRegisteredExchangeAdapters')
            .mockReturnValue(new Promise((resolve) => resolve([undefined, undefined])));
        jest
            .spyOn(registry, 'getMaxRegisteredEntities')
            .mockReturnValue(new Promise((resolve) => resolve(new bignumber_js_1.default(1))));
        const rejects = yield expect(tx.validate()).rejects;
        yield rejects.toThrowError(Registry_error_1.ExchangeAdaptersRegisteredOutOfBoundsError);
        yield rejects.toMatchObject({
            numberOfAdapters: expect.any(Number),
            maxRegisteredAdapters: expect.any(Number),
        });
    }));
    it('should throw AssetAlreadyRegisteredError', () => __awaiter(void 0, void 0, void 0, function* () {
        const tx = registry.registerAsset('', {
            address: '',
            name: '',
            symbol: '',
            url: '',
            reserveMin: new bignumber_js_1.default(0),
            standards: [],
            sigs: [],
        });
        jest.spyOn(registry, 'getAssetInformation').mockReturnValue(new Promise((resolve) => resolve({
            exists: true,
            decimals: 0,
            name: '',
            symbol: '',
            url: '',
            reserveMin: new bignumber_js_1.default(0),
            standards: [],
            sigs: [],
        })));
        jest.spyOn(registry, 'getRegisteredAssets').mockReturnValue(new Promise((resolve) => resolve([undefined])));
        jest
            .spyOn(registry, 'getMaxRegisteredEntities')
            .mockReturnValue(new Promise((resolve) => resolve(new bignumber_js_1.default(2))));
        yield expect(tx.validate()).rejects.toThrowError(Registry_error_1.AssetAlreadyRegisteredError);
    }));
    it('should throw AssetsRegisteredOutOfBoundsError', () => __awaiter(void 0, void 0, void 0, function* () {
        const tx = registry.registerAsset('', {
            address: '',
            name: '',
            symbol: '',
            url: '',
            reserveMin: new bignumber_js_1.default(0),
            standards: [],
            sigs: [],
        });
        jest.spyOn(registry, 'getAssetInformation').mockReturnValue(new Promise((resolve) => resolve({
            exists: false,
            decimals: 0,
            name: '',
            symbol: '',
            url: '',
            reserveMin: new bignumber_js_1.default(0),
            standards: [],
            sigs: [],
        })));
        jest
            .spyOn(registry, 'getRegisteredAssets')
            .mockReturnValue(new Promise((resolve) => resolve([undefined, undefined])));
        jest
            .spyOn(registry, 'getMaxRegisteredEntities')
            .mockReturnValue(new Promise((resolve) => resolve(new bignumber_js_1.default(1))));
        const rejects = expect(tx.validate()).rejects;
        yield rejects.toThrowError(Registry_error_1.AssetsRegisteredOutOfBoundsError);
        yield rejects.toMatchObject({
            numberOfAsset: expect.any(Number),
            maxRegisteredAssets: expect.any(Number),
        });
    }));
    it('should set and get the MLN token', () => __awaiter(void 0, void 0, void 0, function* () {
        const mlnAddress = randomAddress_1.randomAddress();
        const tx = registry.setMlnToken(environment.accounts[0], mlnAddress);
        const txResult = yield tx.send(yield tx.prepare());
        expect(txResult.gasUsed).toBeGreaterThanOrEqual(0);
        expect(txResult.status).toBe(true);
        const result = yield registry.getMlnToken();
        expect(sameAddress_1.sameAddress(result, mlnAddress)).toBe(true);
    }));
    it('should get the incentive amount', () => __awaiter(void 0, void 0, void 0, function* () {
        const result = yield registry.getIncentive();
        expect(result.isEqualTo(new bignumber_js_1.default('1e16'))).toBe(true);
    }));
    it('should check whether a user can use a fund name', () => __awaiter(void 0, void 0, void 0, function* () {
        const result = yield registry.canUseFundName(randomAddress_1.randomAddress(), 'testfund');
        expect(result).toBe(true);
    }));
});
