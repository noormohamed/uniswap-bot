"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Contract_1 = require("../../Contract");
const Registry_abi_1 = require("../../abis/Registry.abi");
const web3_utils_1 = require("web3-utils");
const toBigNumber_1 = require("../../utils/toBigNumber");
const stringToBytes_1 = require("../../utils/stringToBytes");
const hexToString_1 = require("../../utils/hexToString");
const Registry_error_1 = require("./Registry.error");
const DSAuth_1 = require("../dependencies/authorization/DSAuth");
const applyMixins_1 = require("../../utils/applyMixins");
class Registry extends Contract_1.Contract {
    static deploy(environment, bytecode, from, owner) {
        return super.createDeployment(environment, bytecode, from, [owner]);
    }
    getMaxRegisteredEntities(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('MAX_REGISTERED_ENTITIES', undefined, block);
            return toBigNumber_1.toBigNumber(result);
        });
    }
    getEngine(block) {
        return this.makeCall('engine', undefined, block);
    }
    /**
     * Sets the MLN token
     *
     * @param from The address of the sender
     * @param asset The address of the MLN token
     */
    setMlnToken(from, token) {
        return this.createTransaction({ from, method: 'setMlnToken', args: [token] });
    }
    getMlnToken(block) {
        return this.makeCall('mlnToken', undefined, block);
    }
    /**
     * Sets the native asset
     *
     * @param from The address of the sender
     * @param asset The address of the native asset
     */
    setNativeAsset(from, asset) {
        return this.createTransaction({ from, method: 'setNativeAsset', args: [asset] });
    }
    getNativeAsset(block) {
        return this.makeCall('nativeAsset', undefined, block);
    }
    getEthfinexWrapperRegistry(block) {
        return this.makeCall('ethfinexWrapperRegistry', undefined, block);
    }
    getPriceSource(block) {
        return this.makeCall('priceSource', undefined, block);
    }
    getRegisteredAssets(block) {
        return this.makeCall('getRegisteredAssets', undefined, block);
    }
    registerExchangeAdapter(from, registerArgs) {
        const method = 'registerExchangeAdapter';
        const args = [
            registerArgs.exchangeAddress,
            registerArgs.adapterAddress,
            registerArgs.takesCustody,
            registerArgs.sigs,
        ];
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            const info = yield this.getExchangeInformation(registerArgs.adapterAddress);
            if (info.exists) {
                throw new Registry_error_1.ExchangeAdapterAlreadyRegisteredError(registerArgs.adapterAddress);
            }
            const [adapters, max] = yield Promise.all([
                this.getRegisteredExchangeAdapters(),
                this.getMaxRegisteredEntities(),
            ]);
            if (max.isLessThanOrEqualTo(adapters.length)) {
                throw new Registry_error_1.ExchangeAdaptersRegisteredOutOfBoundsError(adapters.length, max.toNumber());
            }
        });
        return this.createTransaction({ from, method, args, validate });
    }
    getRegisteredExchangeAdapters(block) {
        return this.makeCall('getRegisteredExchangeAdapters', undefined, block);
    }
    isExchangeAdapterRegistered(adapter, block) {
        return this.makeCall('exchangeAdapterIsRegistered', [adapter], block);
    }
    /**
     * Register a version
     *
     * @param from The address of the sender
     * @param versionAddress The address of the version
     * @param name The name of the version
     */
    registerVersion(from, versionAddress, name) {
        const method = 'registerVersion';
        const args = [versionAddress, stringToBytes_1.stringToBytes(name, 32)];
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            const versionInformation = yield this.getVersionInformation(versionAddress);
            if (versionInformation.exists) {
                throw new Registry_error_1.VersionAlreadyRegisteredError();
            }
            const versionNameExists = yield this.versionNameExists(name);
            if (versionNameExists) {
                throw new Registry_error_1.VersionNameAlreadyExistsError();
            }
        });
        return this.createTransaction({ from, method, args, validate });
    }
    getRegisteredVersions(block) {
        return this.makeCall('getRegisteredVersions', undefined, block);
    }
    registerAsset(from, registerArgs) {
        const method = 'registerAsset';
        const args = [
            registerArgs.address,
            registerArgs.name,
            registerArgs.symbol,
            registerArgs.url,
            registerArgs.reserveMin.toFixed(0),
            registerArgs.standards,
            registerArgs.sigs.map((sig) => web3_utils_1.hexToBytes(sig)),
        ];
        const validate = () => __awaiter(this, void 0, void 0, function* () {
            const [assets, max] = yield Promise.all([this.getRegisteredAssets(), this.getMaxRegisteredEntities()]);
            if (max.isLessThanOrEqualTo(assets.length)) {
                throw new Registry_error_1.AssetsRegisteredOutOfBoundsError(assets.length, max.toNumber());
            }
            const info = yield this.getAssetInformation(registerArgs.address);
            if (info.exists) {
                throw new Registry_error_1.AssetAlreadyRegisteredError();
            }
        });
        return this.createTransaction({ from, method, args, validate });
    }
    getAssetInformation(assetAddress, block) {
        return this.makeCall('assetInformation', [assetAddress], block);
    }
    getExchangeInformation(adapterAddress, block) {
        return this.makeCall('exchangeInformation', [adapterAddress], block);
    }
    getVersionInformation(versionAddress, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const info = yield this.makeCall('versionInformation', [versionAddress], block);
            if (!info) {
                return undefined;
            }
            return {
                name: hexToString_1.hexToString(info.name),
                exists: info.exists,
            };
        });
    }
    /**
     * Checks if a version name already exists
     *
     * @param name The name of the version
     * @param block The block number to execute the call on.
     */
    versionNameExists(name, block) {
        return this.makeCall('versionNameExists', [stringToBytes_1.stringToBytes(name, 32)], block);
    }
    registerFees(from, feeAddresses) {
        return this.createTransaction({ from, method: 'registerFees', args: [feeAddresses] });
    }
    /**
     * Checks if a fee is already registered
     *
     * @param feeAddress The address of the fee contract
     * @param block The block number to execute the call on.
     */
    isFeeRegistered(feeAddress, block) {
        return this.makeCall('isFeeRegistered', [feeAddress], block);
    }
    /**
     * Checks if an asset is already registered
     *
     * @param asset The address of the asset
     * @param block The block number to execute the call on.
     */
    isAssetRegistered(asset, block) {
        return this.makeCall('assetIsRegistered', [asset], block);
    }
    /**
     * Get the incentive amount
     *
     * @param block The block number to execute the call on.
     */
    getIncentive(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.makeCall('incentive', undefined, block);
            return toBigNumber_1.toBigNumber(result);
        });
    }
    /**
     * Checks whether a fund name is valid
     *
     * @param name The name of the fund
     * @param block The block number to execute the call on.
     */
    isValidFundName(name, block) {
        return this.makeCall('isValidFundName', [name], block);
    }
    /**
     * Checks whether a user can use a certain fund name
     *
     * @param user The address of the user
     * @param name The name of the fund
     * @param block The block number to execute the call on.
     */
    canUseFundName(user, name, block) {
        return this.makeCall('canUseFundName', [user, stringToBytes_1.stringToBytes(name, 32)], block);
    }
    /**
     * Checks if an exchange adapter method is allowed
     *
     * @param adapter The address of the adapter
     * @param signature The encoded signature of the method
     * @param block The block number to execute the call on.
     */
    isAdapterMethodAllowed(adapter, signature, block) {
        return this.makeCall('adapterMethodIsAllowed', [adapter, web3_utils_1.hexToBytes(signature)], block);
    }
}
exports.Registry = Registry;
Registry.abi = Registry_abi_1.RegistryAbi;
applyMixins_1.applyMixins(Registry, [DSAuth_1.DSAuth]);
